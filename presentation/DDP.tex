\documentclass[compress, blue]{beamer}
\usetheme{Warsaw}
\usecolortheme{orchid}
\beamersetuncovermixins{\opaqueness<1>{25}}{\opaqueness<2->{15}}

\usepackage{listings}

% German
\usepackage[ngerman]{babel}

% Read input file as UTF-8
\usepackage[utf8]{inputenc}
% Font encoding: T1 for european languages

\usepackage[T1]{fontenc}
% Textcomp for 128 more characters (including EUR)
\usepackage{textcomp}

% Latin Modern instead of Computer Modern
\usepackage{lmodern}


\definecolor{lineno}{rgb}{0.5,0.5,0.5}
\definecolor{code}{rgb}{0,0.1,0.6}
\definecolor{keyword}{rgb}{0.5,0.1,0.1}
\definecolor{titlebox}{rgb}{0.85,0.85,0.85}
\definecolor{download}{rgb}{0.8,0.1,0.5}
\definecolor{title}{rgb}{0.4,0.4,0.4}

\lstdefinelanguage{clojure}
{
    morekeywords={*agent*, *clojure-version*, *command-line-args*, *compile-files*, *compile-path*, *e, *err*, *file*, *flush-on-newline*, *in*, *ns*, *out*, *print-dup*, *print-length*, *print-level*, *print-meta*, *print-readably*, *read-eval*, *warn-on-reflection*, +, -, ->, ->>, .., /, <, <=, =, ==, >, >=, accessor, aclone, add-classpath, add-watch, agent, agent-error, agent-errors, aget, alength, alias, all-ns, alter, alter-meta!, alter-var-root, amap, ancestors, and, apply, areduce, array-map, aset, aset-boolean, aset-byte, aset-char, aset-double, aset-float, aset-int, aset-long, aset-short, assert, assoc, assoc!, assoc-in, associative?, atom, await, await-for, bases, bean, bigdec, bigint, binding, bit-and, bit-and-not, bit-clear, bit-flip, bit-not, bit-or, bit-set, bit-shift-left, bit-shift-right, bit-test, bit-xor, boolean, boolean-array, booleans, bound-fn, bound-fn*, bound?, butlast, byte, byte-array, bytes, case, cast, char, char-array, char-escape-string, char-name-string, char?, chars, class, class?, clear-agent-errors, clojure-version, coll?, comment, commute, comp, comparator, compare, compare-and-set!, compile, complement, concat, cond, condp, conj, conj!, cons, constantly, construct-proxy, contains?, count, counted?, create-ns, create-struct, cycle, dec, decimal?, declare, definline, defmacro, defmethod, defmulti, defn, defn-,def, defonce, defprotocol, defrecord, defstruct, deftype, delay, delay?, deliver, denominator, deref, derive, descendants, disj, disj!, dissoc, dissoc!, distinct, distinct?, doall, doc, dorun, doseq, dosync, dotimes, doto, double, double-array, doubles, drop, drop-last, drop-while, empty, empty?, ensure, enumeration-seq, error-handler, error-mode, eval, even?, every?, extend, extend-protocol, extend-type, extenders, extends?, false?, ffirst, file-seq, filter, find, find-doc, find-ns, find-var, first, flatten, float, float-array, float?, floats, flush, fn, fn?, fnext, fnil, for, force, format, frequencies, future, future-call, future-cancel, future-cancelled?, future-done?, future?, gen-class, gen-interface, gensym, get, get-in, get-method, get-proxy-class, get-thread-bindings, get-validator, group-by, hash, hash-map, hash-set, identical?, identity, if-let, if-not, ifn?, import, in-ns, inc, init-proxy, instance?, int, int-array, integer?, interleave, intern, interpose, into, into-array, ints, io!, isa?, iterate, iterator-seq, juxt, keep, keep-indexed, key, keys, keyword, keyword?, last, lazy-cat, lazy-seq, let, letfn, line-seq, list, list*, list?, load, load-file, load-reader, load-string, loaded-libs, locking, long, long-array, longs, loop, macroexpand, macroexpand-1, make-array, make-hierarchy, map, map-indexed, map?, mapcat, max, max-key, memfn, memoize, merge, merge-with, meta, methods, min, min-key, mod, name, namespace, namespace-munge, neg?, newline, next, nfirst, nil?, nnext, not, not-any?, not-empty, not-every?, not=, ns, ns-aliases, ns-imports, ns-interns, ns-map, ns-name, ns-publics, ns-refers, ns-resolve, ns-unalias, ns-unmap, nth, nthnext, num, number?, numerator, object-array, odd?, or, parents, partial, partition, partition-all, partition-by, pcalls, peek, persistent!, pmap, pop, pop!, pop-thread-bindings, pos?, pr, pr-str, prefer-method, prefers, print, print-namespace-doc, print-str, printf, println, println-str, prn, prn-str, promise, proxy, proxy-mappings, proxy-super, push-thread-bindings, pvalues, quot, rand, rand-int, rand-nth, range, ratio?, rationalize, re-find, re-groups, re-matcher, re-matches, re-pattern, re-seq, read, read-line, read-string, reduce, reductions, ref, ref-history-count, ref-max-history, ref-min-history, ref-set, refer, refer-clojure, reify, release-pending-sends, rem, remove, remove-all-methods, remove-method, remove-ns, remove-watch, repeat, repeatedly, replace, replicate, require, reset!, reset-meta!, resolve, rest, restart-agent, resultset-seq, reverse, reversible?, rseq, rsubseq, satisfies?, second, select-keys, send, send-off, seq, seq?, seque, sequence, sequential?, set, set-error-handler!, set-error-mode!, set-validator!, set?, short, short-array, shorts, shuffle, shutdown-agents, slurp, some, sort, sort-by, sorted-map, sorted-map-by, sorted-set, sorted-set-by, sorted?, special-form-anchor, special-symbol?, spit, split-at, split-with, str, string?, struct, struct-map, subs, subseq, subvec, supers, swap!, symbol, symbol?, sync, syntax-symbol-anchor, take, take-last, take-nth, take-while, test, the-ns, thread-bound?, time, to-array, to-array-2d, trampoline, transient, tree-seq, true?, type, unchecked-add, unchecked-dec, unchecked-divide, unchecked-inc, unchecked-multiply, unchecked-negate, unchecked-remainder, unchecked-subtract, underive, update-in, update-proxy, use, val, vals, var-get, var-set, var?, vary-meta, vec, vector, vector-of, vector?, when, when-first, when-let, when-not, while, with-bindings, with-bindings*, with-in-str, with-local-vars, with-meta, with-open, with-out-str, with-precision, xml-seq, zero?, zipmap, recur},
   sensitive,
   alsodigit=-,
   morecomment=[l];,
   morestring=[b]"
  }[keywords,comments,strings]

\lstset{
    language=Clojure,
    basicstyle=\ttfamily\small\color{code},
    showspaces=false,
    showstringspaces=false,
    numberfirstline=true,
    numberstyle=\color{lineno}\sffamily\scriptsize,
    keywordstyle=\color{keyword}\bfseries,
    stringstyle=\itshape,
}

\title{Entwurfsmuster in dynamischen Sprachen}
\subtitle{Ein vergleich von Java, Python und Clojure}
\author{Nick Zbinden und Michael Sprecher}
\date{\today}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}\frametitle{Warum und Wie}

\begin{center}
\begin{tabular}{l  l}
  Wer? & Wie?\\
  \hline
  Sprecher, Michael & Python\\
  Zbinden, Nick & Clojure\\
\end{tabular}
\end{center}
\vspace{0.2cm}

\begin{block}{Warum:}
  Um zu zeigen, dass es noch etwas anderes gibt als statisch
  typisierte objektorientiert Sprachen.
\end{block}

\begin{block}{Vorlage: Java}
  \begin{itemize}
    \item limitier statisch typisiert (weakly)
    \item classenbasiertes OO
    \item kaum support für FP
  \end{itemize}
\end{block}

\end{frame}

\begin{frame}\frametitle{Wie und Warum}

\begin{block}{Michael: Python}
  \begin{itemize}
    \item dynamisch typisiert (strongly)
    \item classenbasiertes OO
    \item limiter support für FP
  \end{itemize}
\end{block} 

\begin{block}{Nick: Clojure}
  \begin{itemize}
    \item dynamisch typisiert (strongly)
    \item OO durch multimethods und records
    \item starker support für FP
  \end{itemize}
\end{block}
\end{frame}

\begin{frame}\frametitle{Functional Programming}
  \begin{itemize}
  \item Closure.\pause
    \begin{itemize}
      \item Closure können wie jede andere Variabel behandelt werden.\pause
      \item können in eine Variabeln gespeichert werden.\pause
      \item diese Variabeln können an Funktionen übergeben werden.\pause
      \item sie können anonym erstellt werden (wie string
        z.B. ``anonymer string'') \pause
    \end{itemize}
  \end{itemize}

  \begin{itemize}
  \item pure functions \pause
    \begin{itemize}
       \item funktionen ohne  seiteneffekte \pause
       \item Warum? \pause
         \begin{itemize}
          \item einfache testen und debuggen \pause
          \item einfacher nach zu vollziehen \pause
          \item kann vom Compiler besser obtimiert werden \pause
          \item können einfach parallelisiert werden \pause
         \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}\frametitle{Functional Programming}
  \begin{itemize}
  \item no mutable globale state \pause
    \begin{itemize}
       \item Das geht natürlich nicht immer! Aber das Ziel sehr gross
         geschrieben! \pause
    \end{itemize}
  \end{itemize}

  \begin{itemize}
  \item immutable Data-Structures \pause
    \begin{itemize}
       \item Bei jeder Änderung kommt eine neue Daten
         zurück.
    \end{itemize}
  \end{itemize}
\end{frame}

%Singelton Pattern
  %Clojure

\begin{frame}[fragile]\frametitle{Singelton Pattern}


Braucht man eigentlich nie in FP. 
\pause
\begin{lstlisting}
   (def Global_DB_Connection 
      (global-singleton 
         (fn [] (get-DB "DB info")))
\end{lstlisting}
\pause
\begin{lstlisting}
   (def thread_DB_Connection 
       (per-thread-singleton 
           (fn [] (get-DB "DB info")))
\end{lstlisting}
\end{frame}
  %End Clojure
    
  %Python 
    
  %End Python
    
  %Zusammenfassungsslide

%End Singelton

%Strategie Pattern
  %Clojure

\begin{frame}[fragile]\frametitle{Strategie Pattern in Clojure}
 
Strategien: anstelle von Objekte benützen wir ganz normale Funktionen
\pause
\begin{lstlisting}
  (defn normalflug []
    "normaler Flug")
\end{lstlisting} 
\pause
Enten: anstelle von Enten  benützen wir hash-maps
\pause
\begin{lstlisting}
  (defn ente [anzeigen flug ton]
    {:show anzeigen :fly flug :ton ton})
  (def StockEnte 
    (ente "StockEnte" normalflug  quaken))
\end{lstlisting}
\pause
Keine Basisklasse nur Funktionen die Strategien ausführen 
\pause
\begin{lstlisting}
  (defn fliegen [Ente]
    ((:fly Ente)))
\end{lstlisting} 
\end{frame}

  %End Clojure

  %Python 

  %End Python

  %Zusammenfassungsslide

\begin{frame}\frametitle{Strategie Pattern Fazit:}
  \begin{tabular}{l | l l l}
     & Java &  Python & Clojure  \\
     \hline
    LoC & 123 &  nil & 23  \\
  \end{tabular}
  \vspace{.5cm}

  \begin{block}{Michael:}
   %Dein Schlauer satz
   %einfach das etwas darin ist
    Python kann dank dynamik einiges gut machen.
  \end{block}

  \begin{block}{Nick: }
    First Class Functions sind ein muss für jede Programmiersprache.
  \end{block}
\end{frame}
%end

%Strategie Observer
  %Clojure
\begin{frame}[fragile]\frametitle{Clojure Observer}

Global State:
\pause
  \begin{lstlisting}
    (def WaetherData (ref {:temperature 10 
                           :humidity 20 
                           :presure 15}))
  \end{lstlisting}
\pause
Erhält daten gibt sie richtig aus:
\pause
\begin{lstlisting}
(defn CCDDisplay [old-state {:keys [temperature 
                                    humidity]}]
(println "Current conditions: " temperature 
         "F degrees and " humidity "% humidity"))
\end{lstlisting}
\pause
Jetzt müssen wir sie nur noch richtig verbinden.
\pause
\begin{lstlisting}
(add-watch  WaetherData :CCDDisplay CCDDisplay)
\end{lstlisting}
\end{frame}

  %End Clojure

  %Python 


  %End Python

  %Zusammenfassungsslide

\begin{frame}\frametitle{Observer Fazit:}
   \begin{tabular}{l | l l l}
     & Java &  Python & Clojure  \\
     \hline
    LoC & 128 &  nil & 19  \\
   \end{tabular}

  \begin{block}{Nick:}
    Beide Sprachen haben library support aber Clojure ist 6 mal kürzer.
  \end{block}
\end{frame}

%End

%Strategie Decorater
  %Clojure

\begin{frame}\frametitle{Decorater Clojure:}
  \begin{block}{Problem mit dem Decorater:}
    \begin{itemize}
    \item Daten und Logik sind durcheinander
    \item Logik ist an die Daten gekettet
    \item d.h. Die logik kann nicht wieder verwendet werden
    \item Lösung: Trennung von Daten und Logik
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]\frametitle{Decorater Clojure:}
  Keine Logik bei den Daten:
 \begin{lstlisting}
(def Zutaten {:schoko {:preis 0.2
                       :name "Schoko"}
              :soja {:preis 0.15 
                     :name "Soja"}})
(def Getaenke {:hausmischung {:preis 0.89 
                              :name "Hausmischung"}
               :espresso {:preis 1.99 
                          :name "Esspresso"}})
 \end{lstlisting}
\pause

Machen wir bottum-up programming und fangen mit der API an.
\pause
\begin{lstlisting}
(BuyGetraenk <Hauptgetraenkt>  <List von Zutaten>)
\end{lstlisting}
\pause
\end{frame}

\begin{frame}[fragile]\frametitle{Decorater Clojure:}
Lass uns den Preis berechnen:
\pause
  \begin{lstlisting}
    (defn GetraenkPreis [basis lst-zutaten]
    ;; basis = :espresso
    ;; zutaten = [:schoko :milchschaum]
     (+ (get-in Getraenke [basis :preis])
        (GetData :preis lst-zutaten +)))
    ;; (GetData <welche Daten> 
    ;;          <welche Zutaten> 
    ;;          <wie zusammenziehen>)
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]\frametitle{Decorater Clojure:}

Jetzt lesen wir den Namen heraus: \\
"Expresso: schoko milchschaum"
\pause
  \begin{lstlisting}
(defn GetraenkName [basis lst-zutaten]
  ;; basis = :espresso
  ;; lst-zutaten =  [:schoko :milchschaum]
  (str (get-in Getraenke [basis :name]) ": "
       (GetData :name 
                lst-zutaten 
                #(str \%1 \, " " \%2))))
  ;;   (GetData <welche Daten> 
  ;;            <welche Zutaten>
  ;;            <wie zusammenziehen>)
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]\frametitle{Decorater Clojure:}
  Ok, jetzt wirds schwer.

\begin{lstlisting}
;; (GetData <welche Daten> 
;;          <welche Zutaten> 
;;          <wie zusammenziehen>)
\end{lstlisting}
\begin{lstlisting}
(defn GetGetraenk [basis lst-zutaten Zusammenfasser]
  (reduce Zusammenfasser 
    (map (fn [k] 
            (get-in Zutaten [k basis])) 
         lst-zutaten)))  
\end{lstlisting}

\end{frame}

  %End Clojure

  %Python 

  %End Python

  %Zusammenfassungsslide
\begin{frame}\frametitle{Decorater Fazit:}
    \begin{tabular}{l | l l l}
     & Java &  Python & Clojure  \\
     \hline
    LoC & 100 &  nil & 24  \\
  \end{tabular}
  \begin{block}{Nick: }
    Clojure erlaubtes einen völlig generischen ansatz zu verwenden der
    Daten und Logik trennt. Diese erlaubt es die funktionen 1:1 weiter
    zu verwenden.
  \end{block}
\end{frame}
%End

%Factory Muster
  %Clojure
\begin{frame}[fragile]\frametitle{Clojure Factory}
  Erstellen wir eine "Klasse".\pause
  \begin{lstlisting}
(defrecord Pizza [name teig sosse belag 
                  backen schneiden verpackung])
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]\frametitle{Clojure Factory}

First Version off GetPizza.
\pause
  \begin{lstlisting}
(defn getPizza [name teig sosse belag 
                backen schneiden verpackung] 
   (Pizza. name teig sosse belag
           backen schneiden verpackung)
   ;;new Pizza(name teig ...))
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]\frametitle{Clojure Factory}

Zweite Version von getPizza
\pause
  \begin{lstlisting}
(defn getPizza [name teig sosse belag]
   (Pizza. name teig sosse belag
     "Bache die Pizza fuer 25min bei 350 Grad"
      "Pizza in stuecke schneiden"
      "Pizza in die Schachtel packen"))
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]\frametitle{Clojure Factory}

Multiarity Function
\pause 
\begin{lstlisting}
(defn getPizza
 ([name teig sosse belag]
    (Pizza. name teig sosse belag
        "Bache die Pizza fuer 25min bei 350 Grad"
        "Pizza in stuecke schneiden"
        "Pizza in die Schachtel packen"))
 ([name teig sosse belag backen schneiden verpackung] 
    (Pizza. name teig sosse belag 
            backen schneiden verpackung)))
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]\frametitle{Clojure Factory}

Eine Multimethod passt gut für dieses Problem.
\pause
\begin{lstlisting}
(defmulti BestellePizza (fn [F PT] [F PT]))
\end{lstlisting}
\pause
Eine spezifische Implementation.
\pause
\begin{lstlisting}
(defmethod BestellePizza ["Berlin" "Krabben"] [F T]
           (getPizza "Krabben-Pizza Berliner Art"
                     "fester Kruste"
                     "Marinara-Sosse"
                     ["Geriebener Parmesan" 
                      "Knoblauch" 
                      "Frische Nordsee-Krabben"]))
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]\frametitle{Clojure Factory}

Funktionen die alles zurückgeben was wir brauchen.
\pause
\begin{lstlisting}
(defn bestelle [F T]
  (let [pizza (BestellePizza F T)]
    {:zubereitung (str (MachEine pizza) "\n"
                       (Vorbereitung pizza) "\n"
                       (:backen pizza) "\n"
                       (:schneiden pizza) "\n"
                       (:verpackung pizza) "\n")
     :pizza pizza}))
\end{lstlisting}
\pause
Funktion um den Namen auszulesen.
\pause
\begin{lstlisting}
(defn Pizza-Name [F T]
  (:name :pizza (bestelle F T)))
\end{lstlisting}
\pause
Eine Beispiel.
\pause
\begin{lstlisting}
(println "Ethan bestellte eine " 
          (Pizza-Name "Berlin" "Salami"))
\end{lstlisting}

\end{frame}

  %End Clojure

  %Python 


  %End Python

  %Zusammenfassungsslide

\begin{frame}\frametitle{Factory Fazit:}
    \begin{tabular}{l | l l l}
         & Java &  Python & Clojure  \\
     \hline
        LoC & 240 &  nil & 70 \\
     \end{tabular}
 
  \begin{block}{Nick:}
    Multimethods und records sind eine gute art von OOP.
  \end{block}
\end{frame}

%End



%%%% END SLIDE %%%% 

\begin{frame}\frametitle{Fazit Slide:}
  \begin{block}{Nick:}
    \begin{itemize}
    \item FP macht Programme leichter verstäntlich
    \item Jeder sollte ein bisschen FP lernen
    \end{itemize}
  \end{block}
\end{frame}


\end{document}
